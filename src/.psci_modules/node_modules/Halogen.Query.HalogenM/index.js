"use strict";
var Control_Applicative = require("../Control.Applicative/index.js");
var Control_Applicative_Free = require("../Control.Applicative.Free/index.js");
var Control_Bind = require("../Control.Bind/index.js");
var Control_Category = require("../Control.Category/index.js");
var Control_Monad_Error_Class = require("../Control.Monad.Error.Class/index.js");
var Control_Monad_Free = require("../Control.Monad.Free/index.js");
var Control_Monad_Reader_Class = require("../Control.Monad.Reader.Class/index.js");
var Control_Monad_Rec_Class = require("../Control.Monad.Rec.Class/index.js");
var Control_Monad_Writer_Class = require("../Control.Monad.Writer.Class/index.js");
var Data_Bifunctor = require("../Data.Bifunctor/index.js");
var Data_Eq = require("../Data.Eq/index.js");
var Data_FoldableWithIndex = require("../Data.FoldableWithIndex/index.js");
var Data_Function = require("../Data.Function/index.js");
var Data_Functor = require("../Data.Functor/index.js");
var Data_Map_Internal = require("../Data.Map.Internal/index.js");
var Data_Maybe = require("../Data.Maybe/index.js");
var Data_Newtype = require("../Data.Newtype/index.js");
var Data_Ord = require("../Data.Ord/index.js");
var Data_Traversable = require("../Data.Traversable/index.js");
var Data_Tuple = require("../Data.Tuple/index.js");
var Data_Unit = require("../Data.Unit/index.js");
var Effect_Aff_Class = require("../Effect.Aff.Class/index.js");
var Effect_Class = require("../Effect.Class/index.js");
var Halogen_Data_Slot = require("../Halogen.Data.Slot/index.js");
var Halogen_Query_ChildQuery = require("../Halogen.Query.ChildQuery/index.js");
var Halogen_Subscription = require("../Halogen.Subscription/index.js");

// | The ID value associated with a subscription. Allows the subscription to be
// | stopped at a later time.
var SubscriptionId = function (x) {
    return x;
};

// | The ID value associated with a forked process. Allows the fork to be killed
// | at a later time.
var ForkId = function (x) {
    return x;
};

// | The Halogen component eval algebra.
// |
// | - `state` is the component's state
// | - `action` is the type of actions; events internal to the component that
// |   can be evaluated
// | - `slots` is the set of slots for addressing child components
// | - `output` is the type of output messages the component can raise
// | - `m` is the monad used during evaluation
// | - `a` is the result of the HalogenF expression (see HalogenM for an example).
var State = (function () {
    function State(value0) {
        this.value0 = value0;
    };
    State.create = function (value0) {
        return new State(value0);
    };
    return State;
})();

// | The Halogen component eval algebra.
// |
// | - `state` is the component's state
// | - `action` is the type of actions; events internal to the component that
// |   can be evaluated
// | - `slots` is the set of slots for addressing child components
// | - `output` is the type of output messages the component can raise
// | - `m` is the monad used during evaluation
// | - `a` is the result of the HalogenF expression (see HalogenM for an example).
var Subscribe = (function () {
    function Subscribe(value0, value1) {
        this.value0 = value0;
        this.value1 = value1;
    };
    Subscribe.create = function (value0) {
        return function (value1) {
            return new Subscribe(value0, value1);
        };
    };
    return Subscribe;
})();

// | The Halogen component eval algebra.
// |
// | - `state` is the component's state
// | - `action` is the type of actions; events internal to the component that
// |   can be evaluated
// | - `slots` is the set of slots for addressing child components
// | - `output` is the type of output messages the component can raise
// | - `m` is the monad used during evaluation
// | - `a` is the result of the HalogenF expression (see HalogenM for an example).
var Unsubscribe = (function () {
    function Unsubscribe(value0, value1) {
        this.value0 = value0;
        this.value1 = value1;
    };
    Unsubscribe.create = function (value0) {
        return function (value1) {
            return new Unsubscribe(value0, value1);
        };
    };
    return Unsubscribe;
})();

// | The Halogen component eval algebra.
// |
// | - `state` is the component's state
// | - `action` is the type of actions; events internal to the component that
// |   can be evaluated
// | - `slots` is the set of slots for addressing child components
// | - `output` is the type of output messages the component can raise
// | - `m` is the monad used during evaluation
// | - `a` is the result of the HalogenF expression (see HalogenM for an example).
var Lift = (function () {
    function Lift(value0) {
        this.value0 = value0;
    };
    Lift.create = function (value0) {
        return new Lift(value0);
    };
    return Lift;
})();

// | The Halogen component eval algebra.
// |
// | - `state` is the component's state
// | - `action` is the type of actions; events internal to the component that
// |   can be evaluated
// | - `slots` is the set of slots for addressing child components
// | - `output` is the type of output messages the component can raise
// | - `m` is the monad used during evaluation
// | - `a` is the result of the HalogenF expression (see HalogenM for an example).
var ChildQuery = (function () {
    function ChildQuery(value0) {
        this.value0 = value0;
    };
    ChildQuery.create = function (value0) {
        return new ChildQuery(value0);
    };
    return ChildQuery;
})();

// | The Halogen component eval algebra.
// |
// | - `state` is the component's state
// | - `action` is the type of actions; events internal to the component that
// |   can be evaluated
// | - `slots` is the set of slots for addressing child components
// | - `output` is the type of output messages the component can raise
// | - `m` is the monad used during evaluation
// | - `a` is the result of the HalogenF expression (see HalogenM for an example).
var Raise = (function () {
    function Raise(value0, value1) {
        this.value0 = value0;
        this.value1 = value1;
    };
    Raise.create = function (value0) {
        return function (value1) {
            return new Raise(value0, value1);
        };
    };
    return Raise;
})();

// | The Halogen component eval algebra.
// |
// | - `state` is the component's state
// | - `action` is the type of actions; events internal to the component that
// |   can be evaluated
// | - `slots` is the set of slots for addressing child components
// | - `output` is the type of output messages the component can raise
// | - `m` is the monad used during evaluation
// | - `a` is the result of the HalogenF expression (see HalogenM for an example).
var Par = (function () {
    function Par(value0) {
        this.value0 = value0;
    };
    Par.create = function (value0) {
        return new Par(value0);
    };
    return Par;
})();

// | The Halogen component eval algebra.
// |
// | - `state` is the component's state
// | - `action` is the type of actions; events internal to the component that
// |   can be evaluated
// | - `slots` is the set of slots for addressing child components
// | - `output` is the type of output messages the component can raise
// | - `m` is the monad used during evaluation
// | - `a` is the result of the HalogenF expression (see HalogenM for an example).
var Fork = (function () {
    function Fork(value0, value1) {
        this.value0 = value0;
        this.value1 = value1;
    };
    Fork.create = function (value0) {
        return function (value1) {
            return new Fork(value0, value1);
        };
    };
    return Fork;
})();

// | The Halogen component eval algebra.
// |
// | - `state` is the component's state
// | - `action` is the type of actions; events internal to the component that
// |   can be evaluated
// | - `slots` is the set of slots for addressing child components
// | - `output` is the type of output messages the component can raise
// | - `m` is the monad used during evaluation
// | - `a` is the result of the HalogenF expression (see HalogenM for an example).
var Kill = (function () {
    function Kill(value0, value1) {
        this.value0 = value0;
        this.value1 = value1;
    };
    Kill.create = function (value0) {
        return function (value1) {
            return new Kill(value0, value1);
        };
    };
    return Kill;
})();

// | The Halogen component eval algebra.
// |
// | - `state` is the component's state
// | - `action` is the type of actions; events internal to the component that
// |   can be evaluated
// | - `slots` is the set of slots for addressing child components
// | - `output` is the type of output messages the component can raise
// | - `m` is the monad used during evaluation
// | - `a` is the result of the HalogenF expression (see HalogenM for an example).
var GetRef = (function () {
    function GetRef(value0, value1) {
        this.value0 = value0;
        this.value1 = value1;
    };
    GetRef.create = function (value0) {
        return function (value1) {
            return new GetRef(value0, value1);
        };
    };
    return GetRef;
})();

// | An applicative-only version of `HalogenM` to allow for parallel evaluation.
var HalogenAp = function (x) {
    return x;
};

// | The Halogen component eval effect monad.
// |
// | - `state` is the component's state
// | - `action` is the type of actions; events internal to the component that
// |   can be evaluated
// | - `slots` is the set of slots for addressing child components
// | - `output` is the type of output messages the component can raise
// | - `m` is the monad used during evaluation
// | - `a` is the result of the HalogenM expression. Use the following pattern:
// |     `handleAction :: Action -> H.HalogenM State Action Slots Output m Unit`
// |     `handleQuery  :: forall a. Query a -> H.HalogenM State Action Slots Output m (Maybe a)`
var HalogenM = function (x) {
    return x;
};

// | Unsubscribes a component from a subscription. If the subscription associated
// | with the ID has already ended this will have no effect.
var unsubscribe = function (sid) {
    return HalogenM(Control_Monad_Free.liftF(new Unsubscribe(sid, Data_Unit.unit)));
};

// | An alternative to `subscribe`, intended for subscriptions that unsubscribe
// | themselves. Instead of returning the `SubscriptionId` from `subscribe'`, it
// | is passed into an `Emitter` constructor. This allows emitted queries
// | to include the `SubscriptionId`, rather than storing it in the state of the
// | component.
// |
// | When a component is disposed of any active subscriptions will automatically
// | be stopped and no further subscriptions will be possible during
// | finalization.
var subscribe$prime = function (esc) {
    return HalogenM(Control_Monad_Free.liftF(new Subscribe(esc, Data_Function["const"](Data_Unit.unit))));
};

// | Subscribes a component to an `Emitter`.
// |
// | When a component is disposed of any active subscriptions will automatically
// | be stopped and no further subscriptions will be possible during
// | finalization.
var subscribe = function (es) {
    return HalogenM(Control_Monad_Free.liftF(new Subscribe(function (v) {
        return es;
    }, Control_Category.identity(Control_Category.categoryFn))));
};
var semigroupHalogenM = function (dictSemigroup) {
    return Control_Monad_Free.semigroupFree(dictSemigroup);
};

// | Raises an output message for the component.
var raise = function (o) {
    return HalogenM(Control_Monad_Free.liftF(new Raise(o, Data_Unit.unit)));
};

// | Sends a query to all children of a component at a given slot label.
var queryAll = function (dictCons) {
    return function (dictIsSymbol) {
        return function (dictOrd) {
            return function (label) {
                return function (q) {
                    var catMapMaybes = function (dictOrd1) {
                        return Data_FoldableWithIndex.foldrWithIndex(Data_Map_Internal.foldableWithIndexMap)(function (k) {
                            return function (v) {
                                return function (acc) {
                                    return Data_Maybe.maybe(acc)(Data_Function.flip(Data_Map_Internal.insert(dictOrd1)(k))(acc))(v);
                                };
                            };
                        })(Data_Map_Internal.empty);
                    };
                    return HalogenM(Control_Monad_Free.liftF(ChildQuery.create(Halogen_Query_ChildQuery.mkChildQueryBox(new Halogen_Query_ChildQuery.ChildQuery(function (dictApplicative) {
                        return function (k) {
                            var $128 = Data_Functor.map((dictApplicative.Apply0()).Functor0())(catMapMaybes(dictOrd));
                            var $129 = Data_Traversable.traverse(Data_Map_Internal.traversableMap)(dictApplicative)(k);
                            var $130 = Halogen_Data_Slot.slots()(dictIsSymbol)(dictOrd)(label);
                            return function ($131) {
                                return $128($129($130($131)));
                            };
                        };
                    }, q, Control_Category.identity(Control_Category.categoryFn))))));
                };
            };
        };
    };
};

// | Sends a query to a child of a component at the specified slot.
var query = function (dictCons) {
    return function (dictIsSymbol) {
        return function (dictOrd) {
            return function (label) {
                return function (p) {
                    return function (q) {
                        return HalogenM(Control_Monad_Free.liftF(ChildQuery.create(Halogen_Query_ChildQuery.mkChildQueryBox(new Halogen_Query_ChildQuery.ChildQuery(function (dictApplicative) {
                            return function (k) {
                                var $132 = Data_Maybe.maybe(Control_Applicative.pure(dictApplicative)(Data_Maybe.Nothing.value))(k);
                                var $133 = Halogen_Data_Slot.lookup()(dictIsSymbol)(dictOrd)(label)(p);
                                return function ($134) {
                                    return $132($133($134));
                                };
                            };
                        }, q, Control_Category.identity(Control_Category.categoryFn))))));
                    };
                };
            };
        };
    };
};
var ordSubscriptionId = Data_Ord.ordInt;
var ordForkId = Data_Ord.ordInt;
var newtypeHalogenAp = {
    Coercible0: function () {
        return undefined;
    }
};
var monoidHalogenM = function (dictMonoid) {
    return Control_Monad_Free.monoidFree(dictMonoid);
};
var monadTransHalogenM = {
    lift: function (dictMonad) {
        return function ($135) {
            return HalogenM(Control_Monad_Free.liftF(Lift.create($135)));
        };
    }
};
var monadHalogenM = Control_Monad_Free.freeMonad;
var monadStateHalogenM = {
    state: function ($136) {
        return HalogenM(Control_Monad_Free.liftF(State.create($136)));
    },
    Monad0: function () {
        return monadHalogenM;
    }
};
var monadTellHalogenM = function (dictMonadTell) {
    return {
        tell: (function () {
            var $137 = Control_Monad_Writer_Class.tell(dictMonadTell);
            return function ($138) {
                return HalogenM(Control_Monad_Free.liftF(Lift.create($137($138))));
            };
        })(),
        Semigroup0: dictMonadTell.Semigroup0,
        Monad1: function () {
            return monadHalogenM;
        }
    };
};
var monadThrowHalogenM = function (dictMonadThrow) {
    return {
        throwError: (function () {
            var $139 = Control_Monad_Error_Class.throwError(dictMonadThrow);
            return function ($140) {
                return HalogenM(Control_Monad_Free.liftF(Lift.create($139($140))));
            };
        })(),
        Monad0: function () {
            return monadHalogenM;
        }
    };
};
var monadEffectHalogenM = function (dictMonadEffect) {
    return {
        liftEffect: (function () {
            var $141 = Effect_Class.liftEffect(dictMonadEffect);
            return function ($142) {
                return HalogenM(Control_Monad_Free.liftF(Lift.create($141($142))));
            };
        })(),
        Monad0: function () {
            return monadHalogenM;
        }
    };
};
var monadAskHalogenM = function (dictMonadAsk) {
    return {
        ask: HalogenM(Control_Monad_Free.liftF(new Lift(Control_Monad_Reader_Class.ask(dictMonadAsk)))),
        Monad0: function () {
            return monadHalogenM;
        }
    };
};
var monadAffHalogenM = function (dictMonadAff) {
    return {
        liftAff: (function () {
            var $143 = Effect_Aff_Class.liftAff(dictMonadAff);
            return function ($144) {
                return HalogenM(Control_Monad_Free.liftF(Lift.create($143($144))));
            };
        })(),
        MonadEffect0: function () {
            return monadEffectHalogenM(dictMonadAff.MonadEffect0());
        }
    };
};
var mapOutput = function (f) {
    return function (v) {
        var go = function (v1) {
            if (v1 instanceof State) {
                return new State(v1.value0);
            };
            if (v1 instanceof Subscribe) {
                return new Subscribe(v1.value0, v1.value1);
            };
            if (v1 instanceof Unsubscribe) {
                return new Unsubscribe(v1.value0, v1.value1);
            };
            if (v1 instanceof Lift) {
                return new Lift(v1.value0);
            };
            if (v1 instanceof ChildQuery) {
                return new ChildQuery(v1.value0);
            };
            if (v1 instanceof Raise) {
                return new Raise(f(v1.value0), v1.value1);
            };
            if (v1 instanceof Par) {
                return new Par(Data_Newtype.over()()(HalogenAp)(Control_Applicative_Free.hoistFreeAp(mapOutput(f)))(v1.value0));
            };
            if (v1 instanceof Fork) {
                return new Fork(mapOutput(f)(v1.value0), v1.value1);
            };
            if (v1 instanceof Kill) {
                return new Kill(v1.value0, v1.value1);
            };
            if (v1 instanceof GetRef) {
                return new GetRef(v1.value0, v1.value1);
            };
            throw new Error("Failed pattern match at Halogen.Query.HalogenM (line 279, column 8 - line 289, column 29): " + [ v1.constructor.name ]);
        };
        return Control_Monad_Free.hoistFree(go)(v);
    };
};
var mapAction = function (dictFunctor) {
    return function (f) {
        return function (v) {
            var go = function (v1) {
                if (v1 instanceof State) {
                    return new State(v1.value0);
                };
                if (v1 instanceof Subscribe) {
                    return new Subscribe((function () {
                        var $145 = Data_Functor.map(Halogen_Subscription.functorEmitter)(f);
                        return function ($146) {
                            return $145(v1.value0($146));
                        };
                    })(), v1.value1);
                };
                if (v1 instanceof Unsubscribe) {
                    return new Unsubscribe(v1.value0, v1.value1);
                };
                if (v1 instanceof Lift) {
                    return new Lift(v1.value0);
                };
                if (v1 instanceof ChildQuery) {
                    return new ChildQuery(v1.value0);
                };
                if (v1 instanceof Raise) {
                    return new Raise(v1.value0, v1.value1);
                };
                if (v1 instanceof Par) {
                    return new Par(Data_Newtype.over()()(HalogenAp)(Control_Applicative_Free.hoistFreeAp(mapAction(dictFunctor)(f)))(v1.value0));
                };
                if (v1 instanceof Fork) {
                    return new Fork(mapAction(dictFunctor)(f)(v1.value0), v1.value1);
                };
                if (v1 instanceof Kill) {
                    return new Kill(v1.value0, v1.value1);
                };
                if (v1 instanceof GetRef) {
                    return new GetRef(v1.value0, v1.value1);
                };
                throw new Error("Failed pattern match at Halogen.Query.HalogenM (line 259, column 8 - line 269, column 29): " + [ v1.constructor.name ]);
            };
            return Control_Monad_Free.hoistFree(go)(v);
        };
    };
};

// | Kills a forked process if it is still running. Attempting to kill a forked
// | process that has already ended will have no effect.
var kill = function (fid) {
    return HalogenM(Control_Monad_Free.liftF(new Kill(fid, Data_Unit.unit)));
};
var imapState = function (f) {
    return function (f$prime) {
        return function (v) {
            var go = function (v1) {
                if (v1 instanceof State) {
                    return new State((function () {
                        var $147 = Data_Functor.map(Data_Tuple.functorTuple)(f);
                        return function ($148) {
                            return $147(v1.value0(f$prime($148)));
                        };
                    })());
                };
                if (v1 instanceof Subscribe) {
                    return new Subscribe(v1.value0, v1.value1);
                };
                if (v1 instanceof Unsubscribe) {
                    return new Unsubscribe(v1.value0, v1.value1);
                };
                if (v1 instanceof Lift) {
                    return new Lift(v1.value0);
                };
                if (v1 instanceof ChildQuery) {
                    return new ChildQuery(v1.value0);
                };
                if (v1 instanceof Raise) {
                    return new Raise(v1.value0, v1.value1);
                };
                if (v1 instanceof Par) {
                    return new Par(Data_Newtype.over()()(HalogenAp)(Control_Applicative_Free.hoistFreeAp(imapState(f)(f$prime)))(v1.value0));
                };
                if (v1 instanceof Fork) {
                    return new Fork(imapState(f)(f$prime)(v1.value0), v1.value1);
                };
                if (v1 instanceof Kill) {
                    return new Kill(v1.value0, v1.value1);
                };
                if (v1 instanceof GetRef) {
                    return new GetRef(v1.value0, v1.value1);
                };
                throw new Error("Failed pattern match at Halogen.Query.HalogenM (line 238, column 8 - line 248, column 29): " + [ v1.constructor.name ]);
            };
            return Control_Monad_Free.hoistFree(go)(v);
        };
    };
};
var hoist = function (dictFunctor) {
    return function (nat) {
        return function (v) {
            var go = function (v1) {
                if (v1 instanceof State) {
                    return new State(v1.value0);
                };
                if (v1 instanceof Subscribe) {
                    return new Subscribe(v1.value0, v1.value1);
                };
                if (v1 instanceof Unsubscribe) {
                    return new Unsubscribe(v1.value0, v1.value1);
                };
                if (v1 instanceof Lift) {
                    return new Lift(nat(v1.value0));
                };
                if (v1 instanceof ChildQuery) {
                    return new ChildQuery(v1.value0);
                };
                if (v1 instanceof Raise) {
                    return new Raise(v1.value0, v1.value1);
                };
                if (v1 instanceof Par) {
                    return new Par(Data_Newtype.over()()(HalogenAp)(Control_Applicative_Free.hoistFreeAp(hoist(dictFunctor)(nat)))(v1.value0));
                };
                if (v1 instanceof Fork) {
                    return new Fork(hoist(dictFunctor)(nat)(v1.value0), v1.value1);
                };
                if (v1 instanceof Kill) {
                    return new Kill(v1.value0, v1.value1);
                };
                if (v1 instanceof GetRef) {
                    return new GetRef(v1.value0, v1.value1);
                };
                throw new Error("Failed pattern match at Halogen.Query.HalogenM (line 300, column 8 - line 310, column 29): " + [ v1.constructor.name ]);
            };
            return Control_Monad_Free.hoistFree(go)(v);
        };
    };
};

// | Retrieves an `Element` value that is associated with a `Ref` in the
// | rendered output of a component. If there is no currently rendered value for
// | the requested ref this will return `Nothing`.
var getRef = function (p) {
    return HalogenM(Control_Monad_Free.liftF(new GetRef(p, Control_Category.identity(Control_Category.categoryFn))));
};
var functorHalogenM = Control_Monad_Free.freeFunctor;
var functorHalogenAp = Control_Applicative_Free.functorFreeAp;
var functorHalogenF = function (dictFunctor) {
    return {
        map: function (f) {
            return function (v) {
                if (v instanceof State) {
                    return new State((function () {
                        var $149 = Data_Bifunctor.lmap(Data_Bifunctor.bifunctorTuple)(f);
                        return function ($150) {
                            return $149(v.value0($150));
                        };
                    })());
                };
                if (v instanceof Subscribe) {
                    return new Subscribe(v.value0, function ($151) {
                        return f(v.value1($151));
                    });
                };
                if (v instanceof Unsubscribe) {
                    return new Unsubscribe(v.value0, f(v.value1));
                };
                if (v instanceof Lift) {
                    return new Lift(Data_Functor.map(dictFunctor)(f)(v.value0));
                };
                if (v instanceof ChildQuery) {
                    return new ChildQuery(Data_Functor.map(Halogen_Query_ChildQuery.functorChildQuery)(f)(v.value0));
                };
                if (v instanceof Raise) {
                    return new Raise(v.value0, f(v.value1));
                };
                if (v instanceof Par) {
                    return new Par(Data_Functor.map(functorHalogenAp)(f)(v.value0));
                };
                if (v instanceof Fork) {
                    return new Fork(v.value0, function ($152) {
                        return f(v.value1($152));
                    });
                };
                if (v instanceof Kill) {
                    return new Kill(v.value0, f(v.value1));
                };
                if (v instanceof GetRef) {
                    return new GetRef(v.value0, function ($153) {
                        return f(v.value1($153));
                    });
                };
                throw new Error("Failed pattern match at Halogen.Query.HalogenM (line 56, column 11 - line 66, column 37): " + [ v.constructor.name ]);
            };
        }
    };
};

// | Starts a `HalogenM` process running independent from the current `eval`
// | "thread".
// |
// | A commonly use case for `fork` is in component initializers where some
// | async action is started. Normally all interaction with the component will
// | be blocked until the initializer completes, but if the async action is
// | `fork`ed instead, the initializer can complete synchronously while the
// | async action continues.
// |
// | Some care needs to be taken when using a `fork` that can modify the
// | component state, as it's easy for the forked process to "clobber" the state
// | (overwrite some or all of it with an old value) by mistake.
// |
// | When a component is disposed of any active forks will automatically
// | be killed. New forks can be started during finalization but there will be
// | no means of killing them.
var fork = function (hmu) {
    return HalogenM(Control_Monad_Free.liftF(new Fork(hmu, Control_Category.identity(Control_Category.categoryFn))));
};
var eqSubscriptionId = Data_Eq.eqInt;
var eqForkId = Data_Eq.eqInt;
var bindHalogenM = Control_Monad_Free.freeBind;
var applyHalogenM = Control_Monad_Free.freeApply;
var applyHalogenAp = Control_Applicative_Free.applyFreeAp;
var applicativeHalogenM = Control_Monad_Free.freeApplicative;
var monadRecHalogenM = {
    tailRecM: function (k) {
        return function (a) {
            return Control_Bind.bind(bindHalogenM)(k(a))(function (v) {
                if (v instanceof Control_Monad_Rec_Class.Loop) {
                    return Control_Monad_Rec_Class.tailRecM(monadRecHalogenM)(k)(v.value0);
                };
                if (v instanceof Control_Monad_Rec_Class.Done) {
                    return Control_Applicative.pure(applicativeHalogenM)(v.value0);
                };
                throw new Error("Failed pattern match at Halogen.Query.HalogenM (line 103, column 26 - line 105, column 21): " + [ v.constructor.name ]);
            });
        };
    },
    Monad0: function () {
        return monadHalogenM;
    }
};
var applicativeHalogenAp = Control_Applicative_Free.applicativeFreeAp;
var parallelHalogenM = {
    parallel: function ($154) {
        return HalogenAp(Control_Applicative_Free.liftFreeAp($154));
    },
    sequential: function ($155) {
        return HalogenM(Control_Monad_Free.liftF(Par.create($155)));
    },
    Monad0: function () {
        return monadHalogenM;
    },
    Applicative1: function () {
        return applicativeHalogenAp;
    }
};
module.exports = {
    State: State,
    Subscribe: Subscribe,
    Unsubscribe: Unsubscribe,
    Lift: Lift,
    ChildQuery: ChildQuery,
    Raise: Raise,
    Par: Par,
    Fork: Fork,
    Kill: Kill,
    GetRef: GetRef,
    HalogenM: HalogenM,
    HalogenAp: HalogenAp,
    raise: raise,
    query: query,
    queryAll: queryAll,
    SubscriptionId: SubscriptionId,
    subscribe: subscribe,
    "subscribe'": subscribe$prime,
    unsubscribe: unsubscribe,
    ForkId: ForkId,
    fork: fork,
    kill: kill,
    getRef: getRef,
    imapState: imapState,
    mapAction: mapAction,
    mapOutput: mapOutput,
    hoist: hoist,
    functorHalogenF: functorHalogenF,
    functorHalogenM: functorHalogenM,
    applyHalogenM: applyHalogenM,
    applicativeHalogenM: applicativeHalogenM,
    bindHalogenM: bindHalogenM,
    monadHalogenM: monadHalogenM,
    semigroupHalogenM: semigroupHalogenM,
    monoidHalogenM: monoidHalogenM,
    monadEffectHalogenM: monadEffectHalogenM,
    monadAffHalogenM: monadAffHalogenM,
    parallelHalogenM: parallelHalogenM,
    monadTransHalogenM: monadTransHalogenM,
    monadRecHalogenM: monadRecHalogenM,
    monadStateHalogenM: monadStateHalogenM,
    monadAskHalogenM: monadAskHalogenM,
    monadTellHalogenM: monadTellHalogenM,
    monadThrowHalogenM: monadThrowHalogenM,
    newtypeHalogenAp: newtypeHalogenAp,
    functorHalogenAp: functorHalogenAp,
    applyHalogenAp: applyHalogenAp,
    applicativeHalogenAp: applicativeHalogenAp,
    eqSubscriptionId: eqSubscriptionId,
    ordSubscriptionId: ordSubscriptionId,
    eqForkId: eqForkId,
    ordForkId: ordForkId
};

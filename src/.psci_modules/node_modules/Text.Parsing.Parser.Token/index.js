
// | Functions for working with streams of tokens.
"use strict";
var Control_Alt = require("../Control.Alt/index.js");
var Control_Alternative = require("../Control.Alternative/index.js");
var Control_Applicative = require("../Control.Applicative/index.js");
var Control_Apply = require("../Control.Apply/index.js");
var Control_Bind = require("../Control.Bind/index.js");
var Control_Category = require("../Control.Category/index.js");
var Control_Lazy = require("../Control.Lazy/index.js");
var Control_Monad_State_Class = require("../Control.Monad.State.Class/index.js");
var Data_Array = require("../Data.Array/index.js");
var Data_Boolean = require("../Data.Boolean/index.js");
var Data_Char = require("../Data.Char/index.js");
var Data_CodePoint_Unicode = require("../Data.CodePoint.Unicode/index.js");
var Data_Either = require("../Data.Either/index.js");
var Data_Eq = require("../Data.Eq/index.js");
var Data_Foldable = require("../Data.Foldable/index.js");
var Data_Functor = require("../Data.Functor/index.js");
var Data_Int = require("../Data.Int/index.js");
var Data_List = require("../Data.List/index.js");
var Data_List_Types = require("../Data.List.Types/index.js");
var Data_Maybe = require("../Data.Maybe/index.js");
var Data_Ord = require("../Data.Ord/index.js");
var Data_Ordering = require("../Data.Ordering/index.js");
var Data_Ring = require("../Data.Ring/index.js");
var Data_Semigroup = require("../Data.Semigroup/index.js");
var Data_Show = require("../Data.Show/index.js");
var Data_String_CodePoints = require("../Data.String.CodePoints/index.js");
var Data_String_CodeUnits = require("../Data.String.CodeUnits/index.js");
var Data_String_Common = require("../Data.String.Common/index.js");
var Data_String_Unicode = require("../Data.String.Unicode/index.js");
var Data_Unfoldable = require("../Data.Unfoldable/index.js");
var Data_Unit = require("../Data.Unit/index.js");
var $$Math = require("../Math/index.js");
var Text_Parsing_Parser = require("../Text.Parsing.Parser/index.js");
var Text_Parsing_Parser_Combinators = require("../Text.Parsing.Parser.Combinators/index.js");
var Text_Parsing_Parser_String = require("../Text.Parsing.Parser.String/index.js");

// | The `GenLanguageDef` type is a record that contains all parameterizable
// | features of the "Text.Parsec.Token" module. The module `Text.Parsec.Language`
// | contains some default definitions.
var LanguageDef = function (x) {
    return x;
};
var unGenLanguageDef = function (v) {
    return v;
};

// | Create a parser which Returns the first token in the stream.
var token = function (dictMonad) {
    return function (tokpos) {
        return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(Control_Monad_State_Class.gets(Text_Parsing_Parser.monadStateParserT(dictMonad))(function (v) {
            return v.value0;
        }))(function (input) {
            var v = Data_List.uncons(input);
            if (v instanceof Data_Maybe.Nothing) {
                return Text_Parsing_Parser.fail(dictMonad)("Unexpected EOF");
            };
            if (v instanceof Data_Maybe.Just) {
                return Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(dictMonad))(Control_Monad_State_Class.modify_(Text_Parsing_Parser.monadStateParserT(dictMonad))(function (v1) {
                    return new Text_Parsing_Parser.ParseState(v.value0.tail, tokpos(v.value0.head), true);
                }))(function () {
                    return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(v.value0.head);
                });
            };
            throw new Error("Failed pattern match at Text.Parsing.Parser.Token (line 56, column 3 - line 61, column 16): " + [ v.constructor.name ]);
        });
    };
};

// | Create a parser which matches any token satisfying the predicate.
var when = function (dictMonad) {
    return function (tokpos) {
        return function (f) {
            return Text_Parsing_Parser_Combinators.tryRethrow(dictMonad)(Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(token(dictMonad)(tokpos))(function (a) {
                return Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(dictMonad))(Control_Alternative.guard(Text_Parsing_Parser.alternativeParserT(dictMonad))(f(a)))(function () {
                    return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(a);
                });
            }));
        };
    };
};
var theReservedNames = function (dictMonad) {
    return function (v) {
        if (v.caseSensitive) {
            return Data_Array.sort(Data_Ord.ordString)(v.reservedNames);
        };
        if (Data_Boolean.otherwise) {
            return Data_Array.sort(Data_Ord.ordString)(Data_Functor.map(Data_Functor.functorArray)(Data_String_Common.toLower)(v.reservedNames));
        };
        throw new Error("Failed pattern match at Text.Parsing.Parser.Token (line 728, column 1 - line 728, column 82): " + [ v.constructor.name ]);
    };
};
var simpleSpace = function (dictMonad) {
    return Text_Parsing_Parser_Combinators.skipMany1(dictMonad)(Text_Parsing_Parser_String.satisfyCodePoint(dictMonad)(Data_CodePoint_Unicode.isSpace));
};

//-----------------------------------------------------------------------
// Helper functions that should maybe go in Text.Parsing.Parser.String --
//-----------------------------------------------------------------------
var satisfyCP = function (dictMonad) {
    return function (p) {
        return Text_Parsing_Parser_String.satisfy(dictMonad)(function ($117) {
            return p(Data_String_CodePoints.codePointFromChar($117));
        });
    };
};

// | Parse a space character.  Matches any char that satisfies `Data.CodePoint.Unicode.isSpace`.
var space = function (dictMonad) {
    return Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(satisfyCP(dictMonad)(Data_CodePoint_Unicode.isSpace))("space");
};

// | Parse an uppercase letter.  Matches any char that satisfies `Data.CodePoint.Unicode.isUpper`.
var upper = function (dictMonad) {
    return Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(satisfyCP(dictMonad)(Data_CodePoint_Unicode.isUpper))("uppercase letter");
};
var oneLineComment = function (dictMonad) {
    return function (v) {
        return Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(dictMonad))(Text_Parsing_Parser_Combinators["try"](dictMonad)(Text_Parsing_Parser_String.string(dictMonad)(v.commentLine)))(Text_Parsing_Parser_Combinators.skipMany(dictMonad)(Text_Parsing_Parser_String.satisfy(dictMonad)(function (v1) {
            return v1 !== "\x0a";
        })));
    };
};

// | Parse an octal digit.  Matches any char that satisfies `Data.CodePoint.Unicode.isOctDigit`.
var octDigit = function (dictMonad) {
    return Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(satisfyCP(dictMonad)(Data_CodePoint_Unicode.isOctDigit))("oct digit");
};

// | Match the specified token at the head of the stream.
var match = function (dictMonad) {
    return function (dictEq) {
        return function (tokpos) {
            return function (tok) {
                return when(dictMonad)(tokpos)(function (v) {
                    return Data_Eq.eq(dictEq)(v)(tok);
                });
            };
        };
    };
};

// | Parse an alphabetical character.  Matches any char that satisfies `Data.CodePoint.Unicode.isAlpha`.
var letter = function (dictMonad) {
    return Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(satisfyCP(dictMonad)(Data_CodePoint_Unicode.isAlpha))("letter");
};
var isReserved = function ($copy_names) {
    return function ($copy_name) {
        var $tco_var_names = $copy_names;
        var $tco_done = false;
        var $tco_result;
        function $tco_loop(names, name) {
            var v = Data_Array.uncons(names);
            if (v instanceof Data_Maybe.Nothing) {
                $tco_done = true;
                return false;
            };
            if (v instanceof Data_Maybe.Just) {
                var v1 = Data_Ord.compare(Data_Ord.ordString)(v.value0.head)(name);
                if (v1 instanceof Data_Ordering.LT) {
                    $tco_var_names = v.value0.tail;
                    $copy_name = name;
                    return;
                };
                if (v1 instanceof Data_Ordering.EQ) {
                    $tco_done = true;
                    return true;
                };
                if (v1 instanceof Data_Ordering.GT) {
                    $tco_done = true;
                    return false;
                };
                throw new Error("Failed pattern match at Text.Parsing.Parser.Token (line 723, column 39 - line 726, column 53): " + [ v1.constructor.name ]);
            };
            throw new Error("Failed pattern match at Text.Parsing.Parser.Token (line 721, column 5 - line 726, column 53): " + [ v.constructor.name ]);
        };
        while (!$tco_done) {
            $tco_result = $tco_loop($tco_var_names, $copy_name);
        };
        return $tco_result;
    };
};

// ================================================================================ --
// The following functions should really be in the where-clause of makeTokenParser, --
// but they can't go there because they are mutually recursive.                     --
// ================================================================================ --
//---------------------------------------------------------
// Identifiers & Reserved words
//---------------------------------------------------------
var isReservedName = function (dictMonad) {
    return function (v) {
        return function (name) {
            var caseName = (function () {
                if (v.caseSensitive) {
                    return name;
                };
                if (Data_Boolean.otherwise) {
                    return Data_String_Common.toLower(name);
                };
                throw new Error("Failed pattern match at Text.Parsing.Parser.Token (line 716, column 5 - line 717, column 57): " + [  ]);
            })();
            return isReserved(theReservedNames(dictMonad)(v))(caseName);
        };
    };
};
var inCommentSingle = function (dictMonad) {
    return function (v) {
        var startEnd = Data_Semigroup.append(Data_Semigroup.semigroupArray)(Data_String_CodeUnits.toCharArray(v.commentEnd))(Data_String_CodeUnits.toCharArray(v.commentStart));
        return Control_Lazy.fix(Text_Parsing_Parser.lazyParserT)(function (p) {
            return Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Data_Functor["void"](Text_Parsing_Parser.functorParserT(((dictMonad.Bind1()).Apply0()).Functor0()))(Text_Parsing_Parser_Combinators["try"](dictMonad)(Text_Parsing_Parser_String.string(dictMonad)(v.commentEnd))))(Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(dictMonad))(Text_Parsing_Parser_Combinators.skipMany1(dictMonad)(Text_Parsing_Parser_String.noneOf(dictMonad)(startEnd)))(p)))(Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(dictMonad))(Text_Parsing_Parser_String.oneOf(dictMonad)(startEnd))(p)))("end of comment");
        });
    };
};
var multiLineComment = function (dictMonad) {
    return function (v) {
        return Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(dictMonad))(Text_Parsing_Parser_Combinators["try"](dictMonad)(Text_Parsing_Parser_String.string(dictMonad)(v.commentStart)))(inComment(dictMonad)(v));
    };
};
var inCommentMulti = function (dictMonad) {
    return function (v) {
        var startEnd = Data_Semigroup.append(Data_Semigroup.semigroupArray)(Data_String_CodeUnits.toCharArray(v.commentEnd))(Data_String_CodeUnits.toCharArray(v.commentStart));
        return Control_Lazy.fix(Text_Parsing_Parser.lazyParserT)(function (p) {
            return Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Data_Functor["void"](Text_Parsing_Parser.functorParserT(((dictMonad.Bind1()).Apply0()).Functor0()))(Text_Parsing_Parser_Combinators["try"](dictMonad)(Text_Parsing_Parser_String.string(dictMonad)(v.commentEnd))))(Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(dictMonad))(multiLineComment(dictMonad)(v))(p)))(Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(dictMonad))(Text_Parsing_Parser_Combinators.skipMany1(dictMonad)(Text_Parsing_Parser_String.noneOf(dictMonad)(startEnd)))(p)))(Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(dictMonad))(Text_Parsing_Parser_String.oneOf(dictMonad)(startEnd))(p)))("end of comment");
        });
    };
};
var inComment = function (dictMonad) {
    return function (v) {
        if (v.nestedComments) {
            return inCommentMulti(dictMonad)(v);
        };
        return inCommentSingle(dictMonad)(v);
    };
};

//---------------------------------------------------------
// White space & symbols
//---------------------------------------------------------
var whiteSpace$prime = function (dictMonad) {
    return function (v) {
        if (Data_String_Common["null"](v.commentLine) && Data_String_Common["null"](v.commentStart)) {
            return Text_Parsing_Parser_Combinators.skipMany(dictMonad)(Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(simpleSpace(dictMonad))(""));
        };
        if (Data_String_Common["null"](v.commentLine)) {
            return Text_Parsing_Parser_Combinators.skipMany(dictMonad)(Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(simpleSpace(dictMonad))(multiLineComment(dictMonad)(v)))(""));
        };
        if (Data_String_Common["null"](v.commentStart)) {
            return Text_Parsing_Parser_Combinators.skipMany(dictMonad)(Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(simpleSpace(dictMonad))(oneLineComment(dictMonad)(v)))(""));
        };
        if (Data_Boolean.otherwise) {
            return Text_Parsing_Parser_Combinators.skipMany(dictMonad)(Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(simpleSpace(dictMonad))(oneLineComment(dictMonad)(v)))(multiLineComment(dictMonad)(v)))(""));
        };
        throw new Error("Failed pattern match at Text.Parsing.Parser.Token (line 737, column 1 - line 737, column 86): " + [ v.constructor.name ]);
    };
};

// | Parse a hex digit.  Matches any char that satisfies `Data.CodePoint.Unicode.isHexDigit`.
var hexDigit = function (dictMonad) {
    return Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(satisfyCP(dictMonad)(Data_CodePoint_Unicode.isHexDigit))("hex digit");
};

// | Parse a digit.  Matches any char that satisfies `Data.CodePoint.Unicode.isDecDigit`.
var digit = function (dictMonad) {
    return Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(satisfyCP(dictMonad)(Data_CodePoint_Unicode.isDecDigit))("digit");
};

//---------------------------------------------------------
// Given a LanguageDef, create a token parser.
//---------------------------------------------------------
// | The expression `makeTokenParser language` creates a `GenTokenParser`
// | record that contains lexical parsers that are
// | defined using the definitions in the `language` record.
// |
// | The use of this function is quite stylized - one imports the
// | appropiate language definition and selects the lexical parsers that
// | are needed from the resulting `GenTokenParser`.
// |
// | ```purescript
// | module Main where
// |
// | import Text.Parsing.Parser.Language (haskellDef)
// | import Text.Parsing.Parser.Token (makeTokenParser)
// |
// | -- The parser
// | expr = parens expr
// |    <|> identifier
// |    <|> ...
// |
// |
// | -- The lexer
// | tokenParser = makeTokenParser haskellDef
// | parens      = tokenParser.parens
// | braces      = tokenParser.braces
// | identifier  = tokenParser.identifier
// | reserved    = tokenParser.reserved
// | ...
// | ```
var makeTokenParser = function (dictMonad) {
    return function (v) {
        var stringLetter = Text_Parsing_Parser_String.satisfy(dictMonad)(function (c) {
            return c !== "\"" && (c !== "\\" && c > "\x1a");
        });
        var sign = function (dictRing) {
            return Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Data_Functor.voidLeft(Text_Parsing_Parser.functorParserT(((dictMonad.Bind1()).Apply0()).Functor0()))(Text_Parsing_Parser_String["char"](dictMonad)("-"))(Data_Ring.negate(dictRing)))(Data_Functor.voidLeft(Text_Parsing_Parser.functorParserT(((dictMonad.Bind1()).Apply0()).Functor0()))(Text_Parsing_Parser_String["char"](dictMonad)("+"))(Control_Category.identity(Control_Category.categoryFn))))(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(Control_Category.identity(Control_Category.categoryFn)));
        };
        var oper = (function () {
            var go = Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(v.opStart)(function (c) {
                return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(Data_Array.many(Text_Parsing_Parser.alternativeParserT(dictMonad))(Text_Parsing_Parser.lazyParserT)(v.opLetter))(function (cs) {
                    return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(Data_String_CodeUnits.singleton(c) + Data_String_CodeUnits.fromCharArray(cs));
                });
            });
            return Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(go)("operator");
        })();
        var number = function (base) {
            return function (baseDigit) {
                var folder = function (v1) {
                    return function (v2) {
                        if (v1 instanceof Data_Maybe.Nothing) {
                            return Data_Maybe.Nothing.value;
                        };
                        if (v1 instanceof Data_Maybe.Just) {
                            return Data_Functor.map(Data_Maybe.functorMaybe)(function (v3) {
                                return (base * v1.value0 | 0) + v3 | 0;
                            })(Data_CodePoint_Unicode.hexDigitToInt(Data_String_CodePoints.codePointFromChar(v2)));
                        };
                        throw new Error("Failed pattern match at Text.Parsing.Parser.Token (line 603, column 9 - line 603, column 49): " + [ v1.constructor.name, v2.constructor.name ]);
                    };
                };
                return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(Data_Array.some(Text_Parsing_Parser.alternativeParserT(dictMonad))(Text_Parsing_Parser.lazyParserT)(baseDigit))(function (digits) {
                    return Data_Maybe.maybe(Text_Parsing_Parser.fail(dictMonad)("not digits"))(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad)))(Data_Foldable.foldl(Data_Foldable.foldableArray)(folder)(new Data_Maybe.Just(0))(digits));
                });
            };
        };
        var octal = Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(dictMonad))(Text_Parsing_Parser_String.oneOf(dictMonad)([ "o", "O" ]))(number(8)(octDigit(dictMonad)));
        var lexeme = function (p) {
            return Control_Apply.applyFirst(Text_Parsing_Parser.applyParserT(dictMonad))(p)(whiteSpace$prime(dictMonad)(v));
        };
        
        //---------------------------------------------------------
        // Operators & reserved ops
        //---------------------------------------------------------
var reservedOp = function (name) {
            var go = Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(Text_Parsing_Parser_String.string(dictMonad)(name))(function () {
                return Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(Text_Parsing_Parser_Combinators.notFollowedBy(dictMonad)(v.opLetter))("end of " + name);
            });
            return lexeme(Text_Parsing_Parser_Combinators["try"](dictMonad)(go));
        };
        
        //---------------------------------------------------------
        // White space & symbols
        //---------------------------------------------------------
var symbol = function (name) {
            return Data_Functor.voidLeft(Text_Parsing_Parser.functorParserT(((dictMonad.Bind1()).Apply0()).Functor0()))(lexeme(Text_Parsing_Parser_String.string(dictMonad)(name)))(name);
        };
        
        //---------------------------------------------------------
        // Bracketing
        //---------------------------------------------------------
var parens = function (p) {
            return Text_Parsing_Parser_Combinators.between(dictMonad)(symbol("("))(symbol(")"))(p);
        };
        var semi = symbol(";");
        var semiSep = function (p) {
            return Text_Parsing_Parser_Combinators.sepBy(dictMonad)(p)(semi);
        };
        var semiSep1 = function (p) {
            return Text_Parsing_Parser_Combinators.sepBy1(dictMonad)(p)(semi);
        };
        var isReservedOp = function (name) {
            return isReserved(Data_Array.sort(Data_Ord.ordString)(v.reservedOpNames))(name);
        };
        var operator = (function () {
            var go = Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(oper)(function (name) {
                var $85 = isReservedOp(name);
                if ($85) {
                    return Text_Parsing_Parser.fail(dictMonad)("reserved operator " + name);
                };
                return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(name);
            });
            return lexeme(Text_Parsing_Parser_Combinators["try"](dictMonad)(go));
        })();
        var ident = (function () {
            var go = Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(v.identStart)(function (c) {
                return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(Data_Array.many(Text_Parsing_Parser.alternativeParserT(dictMonad))(Text_Parsing_Parser.lazyParserT)(v.identLetter))(function (cs) {
                    return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(Data_String_CodeUnits.singleton(c) + Data_String_CodeUnits.fromCharArray(cs));
                });
            });
            return Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(go)("identifier");
        })();
        var identifier = (function () {
            var go = Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(ident)(function (name) {
                var $86 = isReservedName(dictMonad)(v)(name);
                if ($86) {
                    return Text_Parsing_Parser.fail(dictMonad)("reserved word " + Data_Show.show(Data_Show.showString)(name));
                };
                return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(name);
            });
            return lexeme(Text_Parsing_Parser_Combinators["try"](dictMonad)(go));
        })();
        var hexadecimal = Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(dictMonad))(Text_Parsing_Parser_String.oneOf(dictMonad)([ "x", "X" ]))(number(16)(hexDigit(dictMonad)));
        var fraction = (function () {
            var op = function (v1) {
                return function (v2) {
                    if (v2 instanceof Data_Maybe.Nothing) {
                        return Data_Maybe.Nothing.value;
                    };
                    if (v2 instanceof Data_Maybe.Just) {
                        return Control_Bind.bind(Data_Maybe.bindMaybe)(Data_CodePoint_Unicode.hexDigitToInt(Data_String_CodePoints.codePointFromChar(v1)))(function (int$prime) {
                            return Control_Applicative.pure(Data_Maybe.applicativeMaybe)((v2.value0 + Data_Int.toNumber(int$prime)) / 10.0);
                        });
                    };
                    throw new Error("Failed pattern match at Text.Parsing.Parser.Token (line 553, column 9 - line 553, column 51): " + [ v1.constructor.name, v2.constructor.name ]);
                };
            };
            return Text_Parsing_Parser_Combinators.asErrorMessage(dictMonad)("fraction")(Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(Text_Parsing_Parser_String["char"](dictMonad)("."))(function () {
                return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(Data_Array.some(Text_Parsing_Parser.alternativeParserT(dictMonad))(Text_Parsing_Parser.lazyParserT)(digit(dictMonad)))("fraction"))(function (digits) {
                    return Data_Maybe.maybe(Text_Parsing_Parser.fail(dictMonad)("not digit"))(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad)))(Data_Foldable.foldr(Data_Foldable.foldableArray)(op)(new Data_Maybe.Just(0.0))(digits));
                });
            }));
        })();
        var escapeGap = Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(dictMonad))(Data_Array.some(Text_Parsing_Parser.alternativeParserT(dictMonad))(Text_Parsing_Parser.lazyParserT)(space(dictMonad)))(Text_Parsing_Parser_String["char"](dictMonad)("\\")))("end of string gap");
        var escapeEmpty = Text_Parsing_Parser_String["char"](dictMonad)("&");
        
        // escape code tables
var escMap = Data_Array.zip([ "a", "b", "f", "n", "r", "t", "v", "\\", "\"", "'" ])([ "\x07", "\x08", "\x0c", "\x0a", "\x0d", "\x09", "\x0b", "\\", "\"", "'" ]);
        var dot = symbol(".");
        var decimal = number(10)(digit(dictMonad));
        var exponent$prime = (function () {
            var power = function (e) {
                if (e < 0) {
                    return 1.0 / power(-e | 0);
                };
                if (Data_Boolean.otherwise) {
                    return $$Math.pow(10.0)(Data_Int.toNumber(e));
                };
                throw new Error("Failed pattern match at Text.Parsing.Parser.Token (line 566, column 9 - line 566, column 31): " + [ e.constructor.name ]);
            };
            return Text_Parsing_Parser_Combinators.asErrorMessage(dictMonad)("exponent")(Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(Text_Parsing_Parser_String.oneOf(dictMonad)([ "e", "E" ]))(function () {
                return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(sign(Data_Ring.ringInt))(function (f) {
                    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(decimal)("exponent"))(function (e) {
                        return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(power(f(e)));
                    });
                });
            }));
        })();
        var fractExponent = function (n) {
            var justExponent = Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(exponent$prime)(function (expo) {
                return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(Data_Int.toNumber(n) * expo);
            });
            var fractExponent$prime = Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(fraction)(function (fract) {
                return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(Text_Parsing_Parser_Combinators.option(dictMonad)(1.0)(exponent$prime))(function (expo) {
                    return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))((Data_Int.toNumber(n) + fract) * expo);
                });
            });
            return Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(fractExponent$prime)(justExponent);
        };
        var fractFloat = function (n) {
            return Data_Functor.map(Text_Parsing_Parser.functorParserT(((dictMonad.Bind1()).Apply0()).Functor0()))(Data_Either.Right.create)(fractExponent(n));
        };
        var decimalFloat = Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(decimal)(function (n) {
            return Text_Parsing_Parser_Combinators.option(dictMonad)(new Data_Either.Left(n))(fractFloat(n));
        });
        var zeroNumFloat = Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Data_Functor.map(Text_Parsing_Parser.functorParserT(((dictMonad.Bind1()).Apply0()).Functor0()))(Data_Either.Left.create)(Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(hexadecimal)(octal)))(decimalFloat))(fractFloat(0)))(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(new Data_Either.Left(0)));
        var natFloat = Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(dictMonad))(Text_Parsing_Parser_String["char"](dictMonad)("0"))(zeroNumFloat))(decimalFloat);
        
        //---------------------------------------------------------
        // Numbers
        //---------------------------------------------------------
var naturalOrFloat = Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(lexeme(natFloat))("number");
        
        // floats
var floating = Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(decimal)(fractExponent);
        var $$float = Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(lexeme(floating))("float");
        var zeroNumber = Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(dictMonad))(Text_Parsing_Parser_String["char"](dictMonad)("0"))(Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(hexadecimal)(octal))(decimal))(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(0))))("");
        var nat = Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(zeroNumber)(decimal);
        
        // integers and naturals
var $$int = Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(lexeme(sign(Data_Ring.ringInt)))(function (f) {
            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(nat)(function (n) {
                return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(f(n));
            });
        });
        var integer = Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(lexeme($$int))("integer");
        var natural = Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(lexeme(nat))("natural");
        var comma = symbol(",");
        var commaSep = function (p) {
            return Text_Parsing_Parser_Combinators.sepBy(dictMonad)(p)(comma);
        };
        var commaSep1 = function (p) {
            return Text_Parsing_Parser_Combinators.sepBy1(dictMonad)(p)(comma);
        };
        var colon = symbol(":");
        var charNum = Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(decimal)(Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(dictMonad))(Text_Parsing_Parser_String["char"](dictMonad)("o"))(number(8)(octDigit(dictMonad)))))(Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(dictMonad))(Text_Parsing_Parser_String["char"](dictMonad)("x"))(number(16)(hexDigit(dictMonad)))))(function (code) {
            var $91 = code > 1114111;
            if ($91) {
                return Text_Parsing_Parser.fail(dictMonad)("invalid escape sequence");
            };
            var v1 = Data_Char.fromCharCode(code);
            if (v1 instanceof Data_Maybe.Just) {
                return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(v1.value0);
            };
            if (v1 instanceof Data_Maybe.Nothing) {
                return Text_Parsing_Parser.fail(dictMonad)("invalid character code (should not happen)");
            };
            throw new Error("Failed pattern match at Text.Parsing.Parser.Token (line 451, column 17 - line 453, column 81): " + [ v1.constructor.name ]);
        });
        var charLetter = Text_Parsing_Parser_String.satisfy(dictMonad)(function (c) {
            return c !== "'" && (c !== "\\" && c > "\x1a");
        });
        var charEsc = (function () {
            var parseEsc = function (v1) {
                return Data_Functor.voidLeft(Text_Parsing_Parser.functorParserT(((dictMonad.Bind1()).Apply0()).Functor0()))(Text_Parsing_Parser_String["char"](dictMonad)(v1.value0))(v1.value1);
            };
            return Text_Parsing_Parser_Combinators.choice(Data_Foldable.foldableArray)(dictMonad)(Data_Functor.map(Data_Functor.functorArray)(parseEsc)(escMap));
        })();
        var charControl = Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(Text_Parsing_Parser_String["char"](dictMonad)("^"))(function () {
            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(upper(dictMonad))(function (code) {
                var v1 = Data_Char.fromCharCode((Data_Char.toCharCode(code) - Data_Char.toCharCode("A") | 0) + 1 | 0);
                if (v1 instanceof Data_Maybe.Just) {
                    return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(v1.value0);
                };
                if (v1 instanceof Data_Maybe.Nothing) {
                    return Text_Parsing_Parser.fail(dictMonad)("invalid character code (should not happen)");
                };
                throw new Error("Failed pattern match at Text.Parsing.Parser.Token (line 440, column 9 - line 442, column 73): " + [ v1.constructor.name ]);
            });
        });
        var caseString = function (name) {
            if (v.caseSensitive) {
                return Data_Functor.voidLeft(Text_Parsing_Parser.functorParserT(((dictMonad.Bind1()).Apply0()).Functor0()))(Text_Parsing_Parser_String.string(dictMonad)(name))(name);
            };
            if (Data_Boolean.otherwise) {
                var msg = Data_Show.show(Data_Show.showString)(name);
                var caseChar = function (c) {
                    var v1 = function (v2) {
                        if (Data_Boolean.otherwise) {
                            return Text_Parsing_Parser_String["char"](dictMonad)(c);
                        };
                        throw new Error("Failed pattern match at Text.Parsing.Parser.Token (line 307, column 1 - line 307, column 92): " + [ c.constructor.name ]);
                    };
                    var $102 = Data_CodePoint_Unicode.isAlpha(Data_String_CodePoints.codePointFromChar(c));
                    if ($102) {
                        var $103 = Data_String_CodeUnits.toChar(Data_String_Unicode.toLowerSimple(Data_String_CodeUnits.singleton(c)));
                        if ($103 instanceof Data_Maybe.Just) {
                            var $104 = Data_String_CodeUnits.toChar(Data_String_Unicode.toUpperSimple(Data_String_CodeUnits.singleton(c)));
                            if ($104 instanceof Data_Maybe.Just) {
                                return Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Text_Parsing_Parser_String["char"](dictMonad)($103.value0))(Text_Parsing_Parser_String["char"](dictMonad)($104.value0));
                            };
                            return v1(true);
                        };
                        return v1(true);
                    };
                    return v1(true);
                };
                var walk = function (name$prime) {
                    var v1 = Data_String_CodeUnits.uncons(name$prime);
                    if (v1 instanceof Data_Maybe.Nothing) {
                        return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(Data_Unit.unit);
                    };
                    if (v1 instanceof Data_Maybe.Just) {
                        return Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(dictMonad))(Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(caseChar(v1.value0.head))(msg))(walk(v1.value0.tail));
                    };
                    throw new Error("Failed pattern match at Text.Parsing.Parser.Token (line 657, column 22 - line 659, column 86): " + [ v1.constructor.name ]);
                };
                return Data_Functor.voidLeft(Text_Parsing_Parser.functorParserT(((dictMonad.Bind1()).Apply0()).Functor0()))(walk(name))(name);
            };
            throw new Error("Failed pattern match at Text.Parsing.Parser.Token (line 652, column 5 - line 652, column 52): " + [ name.constructor.name ]);
        };
        
        //---------------------------------------------------------
        // Identifiers & Reserved words
        //---------------------------------------------------------
var reserved = function (name) {
            var go = Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(dictMonad))(caseString(name))(Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(Text_Parsing_Parser_Combinators.notFollowedBy(dictMonad)(v.identLetter))("end of " + name));
            return lexeme(Text_Parsing_Parser_Combinators["try"](dictMonad)(go));
        };
        var brackets = function (p) {
            return Text_Parsing_Parser_Combinators.between(dictMonad)(symbol("["))(symbol("]"))(p);
        };
        var braces = function (p) {
            return Text_Parsing_Parser_Combinators.between(dictMonad)(symbol("{"))(symbol("}"))(p);
        };
        var ascii3codes = [ "NUL", "SOH", "STX", "ETX", "EOT", "ENQ", "ACK", "BEL", "DLE", "DC1", "DC2", "DC3", "DC4", "NAK", "SYN", "ETB", "CAN", "SUB", "ESC", "DEL" ];
        var ascii3 = [ "\x00", "\x01", "\x02", "\x03", "\x04", "\x05", "\x06", "\x07", "\x10", "\x11", "\x12", "\x13", "\x14", "\x15", "\x16", "\x17", "\x18", "\x1a", "\x1b", "\x7f" ];
        var ascii2codes = [ "BS", "HT", "LF", "VT", "FF", "CR", "SO", "SI", "EM", "FS", "GS", "RS", "US", "SP" ];
        var ascii2 = [ "\x08", "\x09", "\x0a", "\x0b", "\x0c", "\x0d", "\x0e", "\x0f", "\x19", "\x1c", "\x1d", "\x1e", "\x1f", " " ];
        var asciiMap = Data_Array.zip(Data_Semigroup.append(Data_Semigroup.semigroupArray)(ascii3codes)(ascii2codes))(Data_Semigroup.append(Data_Semigroup.semigroupArray)(ascii3)(ascii2));
        var charAscii = (function () {
            var parseAscii = function (v1) {
                return Text_Parsing_Parser_Combinators["try"](dictMonad)(Data_Functor.voidLeft(Text_Parsing_Parser.functorParserT(((dictMonad.Bind1()).Apply0()).Functor0()))(Text_Parsing_Parser_String.string(dictMonad)(v1.value0))(v1.value1));
            };
            return Text_Parsing_Parser_Combinators.choice(Data_Foldable.foldableArray)(dictMonad)(Data_Functor.map(Data_Functor.functorArray)(parseAscii)(asciiMap));
        })();
        
        // -- escape codes
var escapeCode = Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(charEsc)(charNum))(charAscii))(charControl))("escape code");
        var charEscape = Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(dictMonad))(Text_Parsing_Parser_String["char"](dictMonad)("\\"))(escapeCode);
        var characterChar = Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(charLetter)(charEscape))("literal character");
        
        //---------------------------------------------------------
        // Chars & Strings
        //---------------------------------------------------------
var charLiteral = (function () {
            var go = Text_Parsing_Parser_Combinators.between(dictMonad)(Text_Parsing_Parser_String["char"](dictMonad)("'"))(Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(Text_Parsing_Parser_String["char"](dictMonad)("'"))("end of character"))(characterChar);
            return Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(lexeme(go))("character");
        })();
        var stringEscape = Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(Text_Parsing_Parser_String["char"](dictMonad)("\\"))(function () {
            return Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Data_Functor.voidLeft(Text_Parsing_Parser.functorParserT(((dictMonad.Bind1()).Apply0()).Functor0()))(escapeGap)(Data_Maybe.Nothing.value))(Data_Functor.voidLeft(Text_Parsing_Parser.functorParserT(((dictMonad.Bind1()).Apply0()).Functor0()))(escapeEmpty)(Data_Maybe.Nothing.value)))(Data_Functor.map(Text_Parsing_Parser.functorParserT(((dictMonad.Bind1()).Apply0()).Functor0()))(Data_Maybe.Just.create)(escapeCode));
        });
        var stringChar = Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Data_Functor.map(Text_Parsing_Parser.functorParserT(((dictMonad.Bind1()).Apply0()).Functor0()))(Data_Maybe.Just.create)(stringLetter))(stringEscape))("string character");
        var stringLiteral = (function () {
            var folder = function (v1) {
                return function (chars) {
                    if (v1 instanceof Data_Maybe.Nothing) {
                        return chars;
                    };
                    if (v1 instanceof Data_Maybe.Just) {
                        return new Data_List_Types.Cons(v1.value0, chars);
                    };
                    throw new Error("Failed pattern match at Text.Parsing.Parser.Token (line 407, column 9 - line 407, column 55): " + [ v1.constructor.name, chars.constructor.name ]);
                };
            };
            var go = Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(Text_Parsing_Parser_Combinators.between(dictMonad)(Text_Parsing_Parser_String["char"](dictMonad)("\""))(Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(Text_Parsing_Parser_String["char"](dictMonad)("\""))("end of string"))(Data_List.many(Text_Parsing_Parser.alternativeParserT(dictMonad))(Text_Parsing_Parser.lazyParserT)(stringChar)))(function (maybeChars) {
                return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(Data_String_CodeUnits.fromCharArray(Data_List.toUnfoldable(Data_Unfoldable.unfoldableArray)(Data_Foldable.foldr(Data_List_Types.foldableList)(folder)(Data_List_Types.Nil.value)(maybeChars))));
            });
            return lexeme(Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(go)("literal string"));
        })();
        var angles = function (p) {
            return Text_Parsing_Parser_Combinators.between(dictMonad)(symbol("<"))(symbol(">"))(p);
        };
        return {
            identifier: identifier,
            reserved: reserved,
            operator: operator,
            reservedOp: reservedOp,
            charLiteral: charLiteral,
            stringLiteral: stringLiteral,
            natural: natural,
            integer: integer,
            "float": $$float,
            naturalOrFloat: naturalOrFloat,
            decimal: decimal,
            hexadecimal: hexadecimal,
            octal: octal,
            symbol: symbol,
            lexeme: lexeme,
            whiteSpace: whiteSpace$prime(dictMonad)(v),
            parens: parens,
            braces: braces,
            angles: angles,
            brackets: brackets,
            semi: semi,
            comma: comma,
            colon: colon,
            dot: dot,
            semiSep: semiSep,
            semiSep1: semiSep1,
            commaSep: commaSep,
            commaSep1: commaSep1
        };
    };
};

// | Parse an alphabetical or numerical character.
// | Matches any char that satisfies `Data.CodePoint.Unicode.isAlphaNum`.
var alphaNum = function (dictMonad) {
    return Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(satisfyCP(dictMonad)(Data_CodePoint_Unicode.isAlphaNum))("letter or digit");
};
module.exports = {
    token: token,
    when: when,
    match: match,
    LanguageDef: LanguageDef,
    unGenLanguageDef: unGenLanguageDef,
    makeTokenParser: makeTokenParser,
    digit: digit,
    hexDigit: hexDigit,
    octDigit: octDigit,
    upper: upper,
    space: space,
    letter: letter,
    alphaNum: alphaNum
};
